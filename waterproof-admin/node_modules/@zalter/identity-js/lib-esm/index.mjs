import * as CBOR from '@stablelib/cbor';
import Base64Url from 'base64url';
import * as Ed25519 from '@stablelib/ed25519';
import * as X25519 from '@stablelib/x25519';
import * as XSalsa20 from '@stablelib/xsalsa20';
import { XChaCha20Poly1305 } from '@stablelib/xchacha20poly1305';
import { Scrypt } from '@stablelib/scrypt';
import { Buffer as Buffer$1 } from 'buffer';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

var _EventEmitter_registry, _EventEmitter_invokerHandle;
/**
 * Cross-platform (web and Node.js) asynchronous event target with debounce capabilities.
 */
class EventEmitter {
    constructor() {
        /**
         * Registry container for event handlers
         * @type {Map}
         * @private
         */
        _EventEmitter_registry.set(this, new Map());
        /**
         * Requested invoke handle produced by either requestAnimation (for web) or requestImmediate (for Node.js).
         * @private
         */
        _EventEmitter_invokerHandle.set(this, void 0);
    }
    /**
     * Static method that does the actual dispatching.
     * @note This is made so that we avoid overloading the stack and referencing in each object.
     * @param {CustomEvent} event
     */
    dispatchEvent(event) {
        const fn = () => {
            if (__classPrivateFieldGet(this, _EventEmitter_registry, "f").get(event.type) instanceof Set) {
                for (const handler of __classPrivateFieldGet(this, _EventEmitter_registry, "f").get(event.type)) {
                    handler(event);
                }
            }
            __classPrivateFieldSet(this, _EventEmitter_invokerHandle, undefined, "f");
        };
        if (typeof globalThis.requestAnimationFrame === 'function') {
            if (__classPrivateFieldGet(this, _EventEmitter_invokerHandle, "f")) {
                globalThis.cancelAnimationFrame(__classPrivateFieldGet(this, _EventEmitter_invokerHandle, "f"));
            }
            __classPrivateFieldSet(this, _EventEmitter_invokerHandle, globalThis.requestAnimationFrame(fn), "f");
        }
        else if (typeof globalThis.setImmediate === 'function') {
            if (__classPrivateFieldGet(this, _EventEmitter_invokerHandle, "f")) {
                globalThis.clearImmediate(__classPrivateFieldGet(this, _EventEmitter_invokerHandle, "f"));
            }
            __classPrivateFieldSet(this, _EventEmitter_invokerHandle, globalThis.setImmediate(fn), "f");
        }
        else {
            throw new Error('Unable to run events.');
        }
    }
    /**
     * Add event listener for the provided type.
     * @param {string} type
     * @param {function} handler
     */
    addEventListener(type, handler) {
        if (typeof __classPrivateFieldGet(this, _EventEmitter_registry, "f").get(type) === 'object' && __classPrivateFieldGet(this, _EventEmitter_registry, "f").get(type) instanceof Set) {
            __classPrivateFieldGet(this, _EventEmitter_registry, "f").get(type).add(handler);
        }
        else {
            __classPrivateFieldGet(this, _EventEmitter_registry, "f").set(type, new Set([handler]));
        }
    }
    /**
     * Removes the provided event listener for the given type.
     * @param {string} type
     * @param {function} handler
     */
    removeEventListener(type, handler) {
        const listeners = __classPrivateFieldGet(this, _EventEmitter_registry, "f").get(type);
        if (listeners instanceof Set) {
            listeners.delete(handler);
        }
    }
}
_EventEmitter_registry = new WeakMap(), _EventEmitter_invokerHandle = new WeakMap();

const BASE_ENDPOINT = {
    authority: 'identity.api.zalter.com',
    scheme: 'https'
};
const API_VERSION = '2022-09-01';

class Credential {
    /**
     * @param {Object} params
     */
    constructor(params) {
        if (typeof params.issSigAlg !== 'string') {
            throw new TypeError('Expected "issSigAlg" to be a string');
        }
        if (!['string', 'number'].includes(typeof params.issSigKeyId)) {
            throw new TypeError('Expected "issSigKeyId" to be a string');
        }
        if (!(params.issSigPubKey instanceof Uint8Array)) {
            throw new TypeError('Expected "issSigPubKey" to be an Uint8Array');
        }
        if (!['string', 'number'].includes(typeof params.subId)) {
            throw new TypeError('Expected "subId" to be a string or a number');
        }
        if (typeof params.subSigAlg !== 'string') {
            throw new TypeError('Expected "subSigAlg" to be a string');
        }
        if (!['string', 'number'].includes(typeof params.subSigKeyId)) {
            throw new TypeError('Expected "subSigKeyId" to be a string');
        }
        if (!(params.subSigPrivKey instanceof Uint8Array)) {
            throw new TypeError('Expected "subSigPrivKey" to be an Uint8Array');
        }
        if (!['string', 'number'].includes(typeof params.projectId)) {
            throw new TypeError('Expected "projectId" to be a string or a number');
        }
        if (!['string', 'number'].includes(typeof params.expiresAt)) {
            throw new TypeError('Expected "expiresAt" to be a string or a number');
        }
        this.issSigAlg = params.issSigAlg;
        this.issSigKeyId = params.issSigKeyId;
        this.issSigPubKey = params.issSigPubKey;
        this.subId = params.subId;
        this.subSigAlg = params.subSigAlg;
        this.subSigKeyId = params.subSigKeyId;
        this.subSigPrivKey = params.subSigPrivKey;
        this.projectId = params.projectId;
        this.expiresAt = params.expiresAt;
    }
}

var ContentType;
(function (ContentType) {
    ContentType["APPLICATION_CBOR"] = "application/cbor";
    ContentType["APPLICATION_JSON"] = "application/json";
})(ContentType = ContentType || (ContentType = {}));
var HttpHeader;
(function (HttpHeader) {
    HttpHeader["AUTHORITY"] = ":authority";
    HttpHeader["CONTENT_TYPE"] = "content-type";
    HttpHeader["DATE"] = "date";
    HttpHeader["METHOD"] = ":method";
    HttpHeader["PATH"] = ":path";
    HttpHeader["STATUS"] = ":status";
    HttpHeader["X_ZALTER_SIGNATURE"] = "x-zalter-signature";
    HttpHeader["X_ZALTER_VERSION"] = "x-zalter-version";
})(HttpHeader = HttpHeader || (HttpHeader = {}));
var HttpMethod;
(function (HttpMethod) {
    HttpMethod["POST"] = "POST";
})(HttpMethod = HttpMethod || (HttpMethod = {}));
var HttpStatus;
(function (HttpStatus) {
    HttpStatus[HttpStatus["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
})(HttpStatus = HttpStatus || (HttpStatus = {}));

class ServiceException extends Error {
    /**
     * @param {object} options
     * @param {string} options.code
     * @param {string} options.message
     */
    constructor(options) {
        super(options.message);
        this.code = options.code;
    }
    toJSON() {
        return {
            code: this.code,
            message: this.message
        };
    }
}
/**
 * @param {Response} response
 * @return {Promise<never>}
 * @throws ServiceException
 */
async function createServiceException(response) {
    var _a, _b;
    let body;
    try {
        switch (response.headers.get(HttpHeader.CONTENT_TYPE)) {
            case ContentType.APPLICATION_CBOR: {
                body = CBOR.decode(new Uint8Array(await response.arrayBuffer()));
                break;
            }
            case ContentType.APPLICATION_JSON: {
                body = await response.json();
                break;
            }
        }
    }
    catch (_c) { }
    throw new ServiceException({
        code: ((_a = body === null || body === void 0 ? void 0 : body.error) === null || _a === void 0 ? void 0 : _a.code) || 'unknown_error',
        message: ((_b = body === null || body === void 0 ? void 0 : body.error) === null || _b === void 0 ? void 0 : _b.message) || 'Something went wrong'
    });
}

var _Logger_instances, _Logger_prefix, _Logger_level, _Logger_write;
const LOG_LEVELS = {
    VERBOSE: 1,
    DEBUG: 2,
    INFO: 3,
    WARN: 4,
    ERROR: 5
};
class Logger {
    /**
     * @param config
     * @param {string} prefix
     * @param {number} [config.level]
     */
    constructor(prefix, config) {
        _Logger_instances.add(this);
        _Logger_prefix.set(this, void 0);
        _Logger_level.set(this, void 0);
        __classPrivateFieldSet(this, _Logger_prefix, prefix, "f");
        if (config === null || config === void 0 ? void 0 : config.level) {
            __classPrivateFieldSet(this, _Logger_level, config.level, "f");
        }
        try {
            const storedLevel = parseInt(globalThis.sessionStorage.getItem('zalter.logLevel'), 10);
            if (storedLevel) {
                __classPrivateFieldSet(this, _Logger_level, storedLevel, "f");
            }
        }
        catch (_a) { }
        __classPrivateFieldSet(this, _Logger_level, __classPrivateFieldGet(this, _Logger_level, "f") || LOG_LEVELS.VERBOSE, "f");
    }
    verbose(...args) {
        __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_write).call(this, 'VERBOSE', ...args);
    }
    debug(...args) {
        __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_write).call(this, 'DEBUG', ...args);
    }
    info(...args) {
        __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_write).call(this, 'INFO', ...args);
    }
    warn(...args) {
        __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_write).call(this, 'WARN', ...args);
    }
    error(...args) {
        __classPrivateFieldGet(this, _Logger_instances, "m", _Logger_write).call(this, 'ERROR', ...args);
    }
}
_Logger_prefix = new WeakMap(), _Logger_level = new WeakMap(), _Logger_instances = new WeakSet(), _Logger_write = function _Logger_write(type, ...args) {
    if (LOG_LEVELS[type] < __classPrivateFieldGet(this, _Logger_level, "f")) {
        return;
    }
    let fn = console.log.bind(console);
    if (type === 'ERROR') {
        fn = console.error.bind(console);
    }
    if (type === 'WARN') {
        fn = console.warn.bind(console);
    }
    fn(`[${__classPrivateFieldGet(this, _Logger_prefix, "f")}]`, ...args);
};

var _LocalStorageCache_store, _MemoryCache_store;
class LocalStorageCache {
    constructor() {
        _LocalStorageCache_store.set(this, globalThis.localStorage);
    }
    get length() {
        return Promise.resolve(__classPrivateFieldGet(this, _LocalStorageCache_store, "f").length);
    }
    clear() {
        __classPrivateFieldGet(this, _LocalStorageCache_store, "f").clear();
        return Promise.resolve();
    }
    getItem(key) {
        return Promise.resolve(__classPrivateFieldGet(this, _LocalStorageCache_store, "f").getItem(key));
    }
    removeItem(key) {
        __classPrivateFieldGet(this, _LocalStorageCache_store, "f").removeItem(key);
        return Promise.resolve();
    }
    setItem(key, value) {
        __classPrivateFieldGet(this, _LocalStorageCache_store, "f").setItem(key, value);
        return Promise.resolve();
    }
}
_LocalStorageCache_store = new WeakMap();
class MemoryCache {
    constructor() {
        _MemoryCache_store.set(this, new Map());
    }
    get length() {
        return Promise.resolve(__classPrivateFieldGet(this, _MemoryCache_store, "f").size);
    }
    clear() {
        __classPrivateFieldGet(this, _MemoryCache_store, "f").clear();
        return Promise.resolve();
    }
    getItem(key) {
        return Promise.resolve(__classPrivateFieldGet(this, _MemoryCache_store, "f").get(key));
    }
    removeItem(key) {
        __classPrivateFieldGet(this, _MemoryCache_store, "f").delete(key);
        return Promise.resolve();
    }
    setItem(key, value) {
        __classPrivateFieldGet(this, _MemoryCache_store, "f").set(key, value);
        return Promise.resolve();
    }
}
_MemoryCache_store = new WeakMap();
function getCache() {
    const testKey = 'zalter.storage-test';
    const testValue = 'i\'m a teapot';
    try {
        globalThis.localStorage.setItem(testKey, testValue);
        if (globalThis.localStorage.getItem(testKey) !== testValue) {
            throw new Error('Invalid LocalStorage behaviour.');
        }
        return new LocalStorageCache();
    }
    catch (_a) {
        return new MemoryCache();
    }
    finally {
        try {
            globalThis.localStorage.removeItem(testKey);
        }
        catch (_b) { }
    }
}

var _TimeDrifter_offset, _TimeDrifter_tolerance;
const TOLERANCE = 5000;
class TimeDrifter {
    /**
     * @param {number} [tolerance]
     */
    constructor(tolerance) {
        /** The current clock offset */
        _TimeDrifter_offset.set(this, 0);
        _TimeDrifter_tolerance.set(this, void 0);
        __classPrivateFieldSet(this, _TimeDrifter_tolerance, tolerance || TOLERANCE, "f");
    }
    /**
     * Returns the drifted date.
     * @return {Date}
     */
    get date() {
        return __classPrivateFieldGet(this, _TimeDrifter_offset, "f") ? new Date(new Date().getTime() + __classPrivateFieldGet(this, _TimeDrifter_offset, "f")) : new Date();
    }
    ;
    /**
     * Updates the current offset and returns whether there was any.
     * @param {Date | string | number} date
     * @return {boolean}
     */
    update(date) {
        const offset = new Date(date).getTime() - new Date().getTime();
        const modified = Math.abs(__classPrivateFieldGet(this, _TimeDrifter_offset, "f") - offset) > __classPrivateFieldGet(this, _TimeDrifter_tolerance, "f");
        if (modified) {
            __classPrivateFieldSet(this, _TimeDrifter_offset, offset, "f");
            return true;
        }
        return false;
    }
    ;
}
_TimeDrifter_offset = new WeakMap(), _TimeDrifter_tolerance = new WeakMap();

var _User_projectId, _User_credential;
class User {
    constructor(params) {
        _User_projectId.set(this, void 0);
        _User_credential.set(this, void 0);
        if (!['string', 'number'].includes(typeof params.projectId)) {
            throw new TypeError('Expected "projectId" to be a string or a number');
        }
        if (!(params.credential instanceof Credential)) {
            throw new TypeError('Expected "credential" to be a Credential');
        }
        __classPrivateFieldSet(this, _User_projectId, params.projectId, "f");
        __classPrivateFieldSet(this, _User_credential, params.credential, "f");
    }
    get projectId() {
        return __classPrivateFieldGet(this, _User_projectId, "f");
    }
    get issSigAlg() {
        return __classPrivateFieldGet(this, _User_credential, "f").issSigAlg;
    }
    get issSigKeyId() {
        return __classPrivateFieldGet(this, _User_credential, "f").issSigKeyId;
    }
    get subId() {
        return __classPrivateFieldGet(this, _User_credential, "f").subId;
    }
    get subSigAlg() {
        return __classPrivateFieldGet(this, _User_credential, "f").subSigAlg;
    }
    get subSigKeyId() {
        return __classPrivateFieldGet(this, _User_credential, "f").subSigKeyId;
    }
    /**
     * Sign a message using the session credentials.
     * @param {Uint8Array} data
     * @return {Uint8Array}
     */
    signMessage(data) {
        return Ed25519.sign(__classPrivateFieldGet(this, _User_credential, "f").subSigPrivKey, data);
    }
    /**
     * Verify a message signature using the session credentials.
     * @note You should not use this directly since it is used to verify the identity provider server response.
     * @param {Uint8Array} data
     * @param {Uint8Array} signature
     * @return {boolean}
     */
    verifyMessage(data, signature) {
        return Ed25519.verify(__classPrivateFieldGet(this, _User_credential, "f").issSigPubKey, data, signature);
    }
}
_User_projectId = new WeakMap(), _User_credential = new WeakMap();

const assert = (value, msg) => {
    if (!value) {
        throw new Error(msg);
    }
};

/**
 * Concat Uint8Arrays
 * @param {Uint8Array} inputArrays
 * @return {Uint8Array}
 */
function concatUint8Arrays(...inputArrays) {
    const neededLength = inputArrays.reduce((sum, buff) => sum + buff.length, 0);
    const outputArray = new Uint8Array(neededLength);
    let offset = 0;
    for (const arr of inputArrays) {
        outputArray.set(arr, offset);
        offset += arr.length;
    }
    return outputArray;
}

class Random {
    /**
     * Generate random Uint8Array
     * @param {number} length
     * @return {Uint8Array}
     */
    static uint8Array(length) {
        const vector = globalThis.crypto.getRandomValues(new Uint8Array(length));
        const xorb = Math.floor(Math.random() * 1e12) % 256;
        for (let i = 0; i < vector.length; i++) {
            vector[i] ^= xorb;
        }
        return vector;
    }
}

var _Auth_instances, _Auth_projectId, _Auth_apiClient, _Auth_cache, _Auth_user, _Auth_state, _Auth_signInCodeStart, _Auth_signInCodeContinue, _Auth_signInCodeFinalize, _Auth_signInLinkStart, _Auth_signInLinkFinalize, _Auth_authenticate;
const EMPTY_BUFFER = Buffer$1.alloc(0);
const scrypt = new Scrypt(4096, 4, 1);
const logger$1 = new Logger('Auth');
var Endpoint;
(function (Endpoint) {
    Endpoint["START_CODE_SIGN_IN"] = "/v1/auth/signIn/code:start";
    Endpoint["CONTINUE_CODE_SIGN_IN"] = "/v1/auth/signIn/code:continue";
    Endpoint["FINALIZE_CODE_SIGN_IN"] = "/v1/auth/signIn/code:finalize";
    Endpoint["START_LINK_SIGN_IN"] = "/v1/auth/signIn/link:start";
    Endpoint["FINALIZE_LINK_SIGN_IN"] = "/v1/auth/signIn/link:finalize";
    Endpoint["VERIFY_MFA_CHALLENGE"] = "/v1beta/auth/factors/challenge:verify";
    Endpoint["SIGN_OUT"] = "/v1/account/sessions:deleteCurrent";
})(Endpoint || (Endpoint = {}));
var CoseAlgorithm;
(function (CoseAlgorithm) {
    CoseAlgorithm[CoseAlgorithm["xChaCha20Poly1305"] = 24] = "xChaCha20Poly1305";
    CoseAlgorithm["XSalsa20"] = "x:520"; // custom
})(CoseAlgorithm || (CoseAlgorithm = {}));
var CoseHeader;
(function (CoseHeader) {
    CoseHeader[CoseHeader["alg"] = 1] = "alg";
    CoseHeader[CoseHeader["IV"] = 5] = "IV";
})(CoseHeader || (CoseHeader = {}));
/**
 * A client for the Zalter Identity Service API.
 */
class Auth {
    /**
     * @param {AuthConfig} config
     */
    constructor(config) {
        _Auth_instances.add(this);
        this.emitter = new EventEmitter();
        _Auth_projectId.set(this, void 0);
        _Auth_apiClient.set(this, void 0);
        _Auth_cache.set(this, void 0);
        /** In memory cached user for quick access */
        _Auth_user.set(this, null);
        /** Internal state during authentication process */
        _Auth_state.set(this, null);
        if (!config) {
            throw new Error('Configuration is required.');
        }
        if (!config.projectId) {
            throw new Error('Project ID is required.');
        }
        __classPrivateFieldSet(this, _Auth_projectId, config.projectId, "f");
        // Setup cache storage
        __classPrivateFieldSet(this, _Auth_cache, getCache(), "f");
        // Setup API Client
        __classPrivateFieldSet(this, _Auth_apiClient, new ApiClient({
            endpoint: config.endpoint || BASE_ENDPOINT,
            timeDrifter: new TimeDrifter(),
            auth: this
        }), "f");
    }
    /**
     * Return the authentication state.
     * @return {Promise<boolean>}
     */
    async isAuthenticated() {
        return !!await this.getCurrentUser();
    }
    /**
     * Get the authenticated user.
     * @return {Promise<any>}
     */
    async getCurrentUser() {
        if (__classPrivateFieldGet(this, _Auth_user, "f")) {
            return __classPrivateFieldGet(this, _Auth_user, "f");
        }
        const cachePrefix = `zalter.auth.${__classPrivateFieldGet(this, _Auth_projectId, "f")}`;
        const currentUserCacheKey = `${cachePrefix}.currentUser`;
        const currentUserId = await __classPrivateFieldGet(this, _Auth_cache, "f").getItem(currentUserCacheKey);
        if (!currentUserId) {
            return null;
        }
        let user = null;
        const userCacheKey = `${cachePrefix}.users.${currentUserId}`;
        const rawData = await __classPrivateFieldGet(this, _Auth_cache, "f").getItem(userCacheKey);
        if (rawData) {
            try {
                const data = CBOR.decode(Buffer$1.from(rawData, 'base64'));
                // TODO: Check if credential expired
                const credential = new Credential({
                    issSigAlg: data.issSigAlg,
                    issSigKeyId: data.issSigKeyId,
                    issSigPubKey: data.issSigPubKey,
                    subId: data.subId,
                    subSigAlg: data.subSigAlg,
                    subSigKeyId: data.subSigKeyId,
                    subSigPrivKey: data.subSigPrivKey,
                    projectId: data.projectId,
                    expiresAt: data.expiresAt
                });
                user = new User({
                    projectId: data.projectId,
                    credential
                });
            }
            catch (err) {
                logger$1.error('Unable to decode the credential, removing it from cache.', err);
                __classPrivateFieldGet(this, _Auth_cache, "f").removeItem(userCacheKey).catch(logger$1.error);
                __classPrivateFieldGet(this, _Auth_cache, "f").removeItem(currentUserCacheKey).catch(logger$1.error);
            }
        }
        __classPrivateFieldSet(this, _Auth_user, user, "f");
        return __classPrivateFieldGet(this, _Auth_user, "f");
    }
    /**
     * Sign in with a code.
     * @param {"start" | "finalize"} flow
     * @param {unknown} params
     * @return {Promise<void>}
     */
    signInWithCode(flow, params) {
        switch (flow) {
            case 'start':
                return __classPrivateFieldGet(this, _Auth_instances, "m", _Auth_signInCodeStart).call(this, params);
            case 'finalize':
                return __classPrivateFieldGet(this, _Auth_instances, "m", _Auth_signInCodeContinue).call(this, params);
            default:
                throw new Error('Invalid flow');
        }
    }
    /**
     * Sign in with a link.
     * @param {"start" | "finalize"} flow
     * @param {unknown} params
     * @return {Promise<void>}
     */
    signInWithLink(flow, params) {
        switch (flow) {
            case 'start':
                return __classPrivateFieldGet(this, _Auth_instances, "m", _Auth_signInLinkStart).call(this, params);
            case 'finalize':
                return __classPrivateFieldGet(this, _Auth_instances, "m", _Auth_signInLinkFinalize).call(this, params);
            default:
                throw new Error('Invalid flow');
        }
    }
    /**
     * Verify MFA challenge.
     * @param {Object} params
     * @return {Promise<any>}
     */
    verifyMfaChallenge(params) {
        var _a;
        assert((_a = __classPrivateFieldGet(this, _Auth_state, "f")) === null || _a === void 0 ? void 0 : _a.sharedKey, 'Must finish primary authentication');
        assert(params.factorId, 'Authenticator ID is required');
        assert(params.code, 'Code is required');
        const xChaCha20Poly1305 = new XChaCha20Poly1305(__classPrivateFieldGet(this, _Auth_state, "f").sharedKey);
        // Data to encrypt
        const data = {
            factorId: params.factorId,
            code: params.code
        };
        // Encrypt data
        const nonce = Random.uint8Array(24);
        const ciphertext = xChaCha20Poly1305.seal(nonce, CBOR.encode(data));
        const encrypted = CBOR.encode([
            EMPTY_BUFFER,
            {
                [CoseHeader.alg]: CoseAlgorithm.xChaCha20Poly1305,
                [CoseHeader.IV]: nonce
            },
            ciphertext
        ]);
        return __classPrivateFieldGet(this, _Auth_apiClient, "f")
            .request({
            path: Endpoint.VERIFY_MFA_CHALLENGE,
            method: HttpMethod.POST,
            headers: {
                [HttpHeader.CONTENT_TYPE]: ContentType.APPLICATION_CBOR
            },
            body: CBOR.encode({
                sessionId: __classPrivateFieldGet(this, _Auth_state, "f").sessionId,
                encrypted
            })
        })
            .then(async (response) => {
            if (response.status >= 300) {
                return createServiceException(response);
            }
            const payload = CBOR.decode(new Uint8Array(await response.arrayBuffer()));
            if (payload.status === 'AUTHENTICATED') {
                const encrypted = CBOR.decode(payload.encrypted);
                // Decrypt and decode authDetails
                const { authDetails } = CBOR.decode(xChaCha20Poly1305.open(encrypted[1][CoseHeader.IV], encrypted[2]));
                // Cleanup internal state
                const subSigPrivKey = __classPrivateFieldGet(this, _Auth_state, "f").subSigPrivKey;
                __classPrivateFieldSet(this, _Auth_state, null, "f");
                await __classPrivateFieldGet(this, _Auth_instances, "m", _Auth_authenticate).call(this, {
                    issSigAlg: authDetails.issSigAlg,
                    issSigKeyId: authDetails.issSigKeyId,
                    issSigPubKey: authDetails.issSigPubKey,
                    subId: authDetails.subId,
                    subSigAlg: authDetails.subSigAlg,
                    subSigKeyId: authDetails.subSigKeyId,
                    subSigPrivKey,
                    projectId: __classPrivateFieldGet(this, _Auth_projectId, "f"),
                    expiresAt: authDetails.expiresAt
                });
                return {
                    status: 'AUTHENTICATED'
                };
            }
            throw new Error('Status handler not implemented');
        });
    }
    /**
     * Sign out.
     * @param {boolean} [globalSignOut = true] - Sign out from server
     * @return {Promise<void>}
     */
    async signOut(globalSignOut = true) {
        const user = await this.getCurrentUser();
        if (!user) {
            logger$1.error('Unable to sign out, user not signed in.');
            return;
        }
        if (globalSignOut) {
            try {
                const response = await __classPrivateFieldGet(this, _Auth_apiClient, "f").request({
                    path: Endpoint.SIGN_OUT,
                    method: HttpMethod.POST,
                    options: {
                        signRequest: true,
                        verifyResponse: true
                    }
                });
                if (response.status >= 300) {
                    await createServiceException(response);
                    return;
                }
            }
            catch (err) {
                logger$1.error('Unable to sign out from server.', err);
                // TODO: Maybe throw here to let the user know
            }
        }
        try {
            const cachePrefix = `zalter.auth.${__classPrivateFieldGet(this, _Auth_projectId, "f")}`;
            await __classPrivateFieldGet(this, _Auth_cache, "f").removeItem(`${cachePrefix}.currentUser`);
            await __classPrivateFieldGet(this, _Auth_cache, "f").removeItem(`${cachePrefix}.users.${user.subId}`);
        }
        catch (err) {
            logger$1.error('Failed to remove local session.', err);
        }
        this.emitter.dispatchEvent(new CustomEvent('signedOut'));
    }
}
_Auth_projectId = new WeakMap(), _Auth_apiClient = new WeakMap(), _Auth_cache = new WeakMap(), _Auth_user = new WeakMap(), _Auth_state = new WeakMap(), _Auth_instances = new WeakSet(), _Auth_signInCodeStart = 
/**
 * Start sign in with code process.
 * @param {Object} params
 * @return {Promise<void>}
 * @private
 */
async function _Auth_signInCodeStart(params) {
    assert(params.email || params.phoneNumber, 'Email or phone number is required');
    // Generate subject DH key pair
    const subDhKeyPair = X25519.generateKeyPair();
    return __classPrivateFieldGet(this, _Auth_apiClient, "f")
        .request({
        path: Endpoint.START_CODE_SIGN_IN,
        method: HttpMethod.POST,
        headers: {
            [HttpHeader.CONTENT_TYPE]: ContentType.APPLICATION_CBOR
        },
        body: CBOR.encode(Object.assign({ projectId: __classPrivateFieldGet(this, _Auth_projectId, "f"), dhPubKey: subDhKeyPair.publicKey }, (params.email ? { email: params.email } : { phoneNumber: params.phoneNumber })))
    })
        .then(async (response) => {
        if (response.status >= 300) {
            return createServiceException(response);
        }
        const payload = CBOR.decode(new Uint8Array(await response.arrayBuffer()));
        // Compute shared key
        const sharedKey = X25519.sharedKey(subDhKeyPair.secretKey, payload.dhPubKey, true);
        __classPrivateFieldSet(this, _Auth_state, {
            sessionId: payload.sessionId,
            sharedKey
        }, "f");
    });
}, _Auth_signInCodeContinue = 
/**
 * Continue sign in with code process.
 * @param {Object} params
 * @return {Promise<void>}
 * @private
 */
async function _Auth_signInCodeContinue(params) {
    var _a;
    assert((_a = __classPrivateFieldGet(this, _Auth_state, "f")) === null || _a === void 0 ? void 0 : _a.sharedKey, 'Must initiate authentication');
    assert(params.code, 'Code is required');
    const code = new Uint8Array(Buffer$1.from(params.code));
    // Derive shared key
    const derivedSharedKey = scrypt.deriveKey(code, __classPrivateFieldGet(this, _Auth_state, "f").sharedKey, 32);
    // Generate subject signing key pair and challenge
    const subSigKeyPair = Ed25519.generateKeyPair();
    const subChallenge = Random.uint8Array(64);
    // Compute data to encrypt
    const data = concatUint8Arrays(subSigKeyPair.publicKey, subChallenge);
    // Encrypt data
    const nonce = Random.uint8Array(24);
    const ciphertext = new Uint8Array(data.length);
    XSalsa20.streamXOR(derivedSharedKey, nonce, data, ciphertext);
    const encrypted = CBOR.encode([
        EMPTY_BUFFER,
        {
            [CoseHeader.alg]: CoseAlgorithm.XSalsa20,
            [CoseHeader.IV]: nonce
        },
        ciphertext
    ]);
    return __classPrivateFieldGet(this, _Auth_apiClient, "f")
        .request({
        path: Endpoint.CONTINUE_CODE_SIGN_IN,
        method: HttpMethod.POST,
        headers: {
            [HttpHeader.CONTENT_TYPE]: ContentType.APPLICATION_CBOR
        },
        body: CBOR.encode({
            sessionId: __classPrivateFieldGet(this, _Auth_state, "f").sessionId,
            encrypted
        })
    })
        .then(async (response) => {
        if (response.status >= 300) {
            return createServiceException(response);
        }
        const payload = CBOR.decode(new Uint8Array(await response.arrayBuffer()));
        // Derive shared key
        const derivedSharedKey = scrypt.deriveKey(subChallenge, __classPrivateFieldGet(this, _Auth_state, "f").sharedKey, 32);
        // Decode encrypted struct
        const encrypted = CBOR.decode(payload.encrypted);
        // Decrypt data
        const data = new Uint8Array(160);
        XSalsa20.streamXOR(derivedSharedKey, encrypted[1][CoseHeader.IV], encrypted[2], data);
        // Unwrap data
        const issSigPubKey = data.slice(0, 32);
        const issChallenge = data.slice(32, 96);
        const issProof = data.slice(96, 160);
        // Verify issuer proof
        const isProofValid = Ed25519.verify(issSigPubKey, subChallenge, issProof);
        if (!isProofValid) {
            logger$1.error('Invalid issuer proof');
            throw new Error('Invalid confirmation code');
        }
        // Persist data for finalize
        __classPrivateFieldSet(this, _Auth_state, {
            sessionId: __classPrivateFieldGet(this, _Auth_state, "f").sessionId,
            sharedKey: __classPrivateFieldGet(this, _Auth_state, "f").sharedKey,
            issChallenge: issChallenge,
            issSigPubKey: issSigPubKey,
            subSigPrivKey: subSigKeyPair.secretKey
        }, "f");
        return __classPrivateFieldGet(this, _Auth_instances, "m", _Auth_signInCodeFinalize).call(this);
    });
}, _Auth_signInCodeFinalize = 
/**
 * Finalize sign in with code process.
 * @return Promise<void>
 * @private
 */
async function _Auth_signInCodeFinalize() {
    // Derive shared key
    const derivedSharedKey = scrypt.deriveKey(__classPrivateFieldGet(this, _Auth_state, "f").issChallenge, __classPrivateFieldGet(this, _Auth_state, "f").sharedKey, 32);
    // Compute data to encrypt
    const data = Ed25519.sign(__classPrivateFieldGet(this, _Auth_state, "f").subSigPrivKey, __classPrivateFieldGet(this, _Auth_state, "f").issChallenge);
    // Encrypt data
    const nonce = Random.uint8Array(24);
    const ciphertext = new Uint8Array(data.length);
    XSalsa20.streamXOR(derivedSharedKey, nonce, data, ciphertext);
    const encrypted = CBOR.encode([
        EMPTY_BUFFER,
        {
            [CoseHeader.alg]: CoseAlgorithm.XSalsa20,
            [CoseHeader.IV]: nonce
        },
        ciphertext
    ]);
    return __classPrivateFieldGet(this, _Auth_apiClient, "f")
        .request({
        path: Endpoint.FINALIZE_CODE_SIGN_IN,
        method: HttpMethod.POST,
        headers: {
            [HttpHeader.CONTENT_TYPE]: ContentType.APPLICATION_CBOR
        },
        body: CBOR.encode({
            sessionId: __classPrivateFieldGet(this, _Auth_state, "f").sessionId,
            encrypted
        })
    })
        .then(async (response) => {
        if (response.status >= 300) {
            return createServiceException(response);
        }
        const payload = CBOR.decode(new Uint8Array(await response.arrayBuffer()));
        const xChaCha20Poly1305 = new XChaCha20Poly1305(__classPrivateFieldGet(this, _Auth_state, "f").sharedKey);
        if (payload.status === 'MFA_REQUIRED') {
            const encrypted = CBOR.decode(payload.encrypted);
            // Decrypt and decode
            const { factors } = CBOR.decode(xChaCha20Poly1305.open(encrypted[1][CoseHeader.IV], encrypted[2]));
            return {
                status: 'MFA_REQUIRED',
                factors
            };
        }
        if (payload.status === 'AUTHENTICATED') {
            const encrypted = CBOR.decode(payload.encrypted);
            // Decrypt and decode authDetails
            const { authDetails } = CBOR.decode(xChaCha20Poly1305.open(encrypted[1][CoseHeader.IV], encrypted[2]));
            // Cleanup internal state
            const subSigPrivKey = __classPrivateFieldGet(this, _Auth_state, "f").subSigPrivKey;
            __classPrivateFieldSet(this, _Auth_state, null, "f");
            await __classPrivateFieldGet(this, _Auth_instances, "m", _Auth_authenticate).call(this, {
                issSigAlg: authDetails.issSigAlg,
                issSigKeyId: authDetails.issSigKeyId,
                issSigPubKey: authDetails.issSigPubKey,
                subId: authDetails.subId,
                subSigAlg: authDetails.subSigAlg,
                subSigKeyId: authDetails.subSigKeyId,
                subSigPrivKey,
                projectId: __classPrivateFieldGet(this, _Auth_projectId, "f"),
                expiresAt: authDetails.expiresAt
            });
            return {
                status: 'AUTHENTICATED'
            };
        }
        throw new Error('Status handler not implemented');
    });
}, _Auth_signInLinkStart = 
/**
 * Start sign in with link process.
 * @param {Object} params
 * @return {Promise<void>}
 * @private
 */
async function _Auth_signInLinkStart(params) {
    assert(params.email, 'Email is required');
    assert(params.redirectUri, 'Redirect URI is required');
    const response = await __classPrivateFieldGet(this, _Auth_apiClient, "f").request({
        path: Endpoint.START_LINK_SIGN_IN,
        method: HttpMethod.POST,
        headers: {
            [HttpHeader.CONTENT_TYPE]: ContentType.APPLICATION_CBOR
        },
        body: CBOR.encode({
            projectId: __classPrivateFieldGet(this, _Auth_projectId, "f"),
            email: params.email,
            redirectUri: params.redirectUri
        })
    });
    if (response.status >= 300) {
        await createServiceException(response);
    }
}, _Auth_signInLinkFinalize = 
/**
 * Finalize sign in with link process.
 * @param {Object} params
 * @return {Promise<void>}
 * @private
 */
async function _Auth_signInLinkFinalize(params) {
    assert(params.token, 'Token is required');
    let token;
    try {
        const rawToken = new Uint8Array(Base64Url.toBuffer(params.token));
        token = CBOR.decode(rawToken);
    }
    catch (err) {
        logger$1.error('Unable to decode the token', err);
        throw new Error('Invalid token');
    }
    // Generate subject DH key pair
    const subDhKeyPair = X25519.generateKeyPair();
    // Compute shared key
    const sharedKey = X25519.sharedKey(subDhKeyPair.secretKey, token.dhPubKey, true);
    const xChaCha20Poly1305 = new XChaCha20Poly1305(sharedKey);
    // Generate subject signing key pair and sign the challenge
    const subSigKeyPair = Ed25519.generateKeyPair();
    const subProof = Ed25519.sign(subSigKeyPair.secretKey, token.challenge);
    // Compute data to encrypt
    const data = concatUint8Arrays(subSigKeyPair.publicKey, subProof);
    // Encrypt data
    const nonce = Random.uint8Array(24);
    const ciphertext = xChaCha20Poly1305.seal(nonce, data);
    const encrypted = CBOR.encode([
        EMPTY_BUFFER,
        {
            [CoseHeader.alg]: CoseAlgorithm.xChaCha20Poly1305,
            [CoseHeader.IV]: nonce
        },
        ciphertext
    ]);
    return __classPrivateFieldGet(this, _Auth_apiClient, "f")
        .request({
        path: Endpoint.FINALIZE_LINK_SIGN_IN,
        method: HttpMethod.POST,
        headers: {
            [HttpHeader.CONTENT_TYPE]: ContentType.APPLICATION_CBOR
        },
        body: CBOR.encode({
            sessionId: token.sessionId,
            dhPubKey: subDhKeyPair.publicKey,
            encrypted
        })
    })
        .then(async (response) => {
        if (response.status >= 300) {
            return createServiceException(response);
        }
        const payload = CBOR.decode(new Uint8Array(await response.arrayBuffer()));
        if (payload.status === 'MFA_REQUIRED') {
            const encrypted = CBOR.decode(payload.encrypted);
            // Decrypt and decode
            const { factors } = CBOR.decode(xChaCha20Poly1305.open(encrypted[1][CoseHeader.IV], encrypted[2]));
            // Persist data for MFA verification
            __classPrivateFieldSet(this, _Auth_state, {
                sessionId: token.sessionId,
                sharedKey,
                subSigPrivKey: subSigKeyPair.secretKey
            }, "f");
            return {
                status: 'MFA_REQUIRED',
                factors
            };
        }
        if (payload.status === 'AUTHENTICATED') {
            const encrypted = CBOR.decode(payload.encrypted);
            // Decrypt and decode authDetails
            const { authDetails } = CBOR.decode(xChaCha20Poly1305.open(encrypted[1][CoseHeader.IV], encrypted[2]));
            // Cleanup internal state
            __classPrivateFieldSet(this, _Auth_state, null, "f");
            await __classPrivateFieldGet(this, _Auth_instances, "m", _Auth_authenticate).call(this, {
                issSigAlg: authDetails.issSigAlg,
                issSigKeyId: authDetails.issSigKeyId,
                issSigPubKey: authDetails.issSigPubKey,
                subId: authDetails.subId,
                subSigAlg: authDetails.subSigAlg,
                subSigKeyId: authDetails.subSigKeyId,
                subSigPrivKey: subSigKeyPair.secretKey,
                projectId: __classPrivateFieldGet(this, _Auth_projectId, "f"),
                expiresAt: authDetails.expiresAt
            });
            return {
                status: 'AUTHENTICATED'
            };
        }
        throw new Error('Status handler not implemented');
    });
}, _Auth_authenticate = 
/**
 * Authenticate the user internally.
 * @param {any} params
 * @return {Promise<void>}
 * @private
 */
async function _Auth_authenticate(params) {
    const credential = new Credential({
        issSigAlg: params.issSigAlg,
        issSigKeyId: params.issSigKeyId,
        issSigPubKey: params.issSigPubKey,
        subId: params.subId,
        subSigAlg: params.subSigAlg,
        subSigKeyId: params.subSigKeyId,
        subSigPrivKey: params.subSigPrivKey,
        projectId: params.projectId,
        expiresAt: params.expiresAt
    });
    __classPrivateFieldSet(this, _Auth_user, new User({
        projectId: params.projectId,
        credential
    }), "f");
    const cachePrefix = `zalter.auth.${params.projectId}`;
    await __classPrivateFieldGet(this, _Auth_cache, "f").setItem(`${cachePrefix}.users.${params.subId}`, Buffer$1
        .from(CBOR.encode({
        issSigAlg: params.issSigAlg,
        issSigKeyId: params.issSigKeyId,
        issSigPubKey: params.issSigPubKey,
        subId: params.subId,
        subSigAlg: params.subSigAlg,
        subSigKeyId: params.subSigKeyId,
        subSigPrivKey: params.subSigPrivKey,
        projectId: params.projectId,
        expiresAt: params.expiresAt
    }))
        .toString('base64'));
    await __classPrivateFieldGet(this, _Auth_cache, "f").setItem(`${cachePrefix}.currentUser`, params.subId);
    // Emit the signed in event
    this.emitter.dispatchEvent(new CustomEvent('signedIn'));
};

var _ApiClient_instances, _ApiClient_auth, _ApiClient_endpoint, _ApiClient_timeDrifter, _ApiClient_signRequest, _ApiClient_verifyResponse;
if (!globalThis.fetch) {
    throw new Error('No global fetch implementation found.');
}
const logger = new Logger('API Client');
const addBaseHeaders = (headers) => {
    return Object.assign({}, headers, {
        [HttpHeader.X_ZALTER_VERSION]: API_VERSION
    });
};
class ApiClient {
    /**
     * @param {object} config
     */
    constructor(config) {
        _ApiClient_instances.add(this);
        _ApiClient_auth.set(this, void 0);
        _ApiClient_endpoint.set(this, void 0);
        _ApiClient_timeDrifter.set(this, void 0);
        if (!(config.auth instanceof Auth)) {
            throw Error('auth must be an instance of Auth');
        }
        if (!(config.timeDrifter instanceof TimeDrifter)) {
            throw Error('timeDrifter must be an instance of TimeDrifter');
        }
        if (typeof config.endpoint === 'undefined') {
            throw new Error('Authority must be provided');
        }
        __classPrivateFieldSet(this, _ApiClient_auth, config.auth, "f");
        __classPrivateFieldSet(this, _ApiClient_endpoint, config.endpoint, "f");
        __classPrivateFieldSet(this, _ApiClient_timeDrifter, config.timeDrifter, "f");
    }
    /**
     * Performs the API call.
     * @param {object} params
     * @return {Promise<Response>}
     */
    async request(params) {
        var _a, _b, _c, _d, _e, _f;
        const request = {
            authority: __classPrivateFieldGet(this, _ApiClient_endpoint, "f").authority,
            body: params.body,
            headers: addBaseHeaders(params.headers),
            method: params.method,
            path: params.path,
            scheme: __classPrivateFieldGet(this, _ApiClient_endpoint, "f").scheme
        };
        let user;
        if (((_a = params.options) === null || _a === void 0 ? void 0 : _a.signRequest) || ((_b = params.options) === null || _b === void 0 ? void 0 : _b.verifyResponse)) {
            try {
                user = await __classPrivateFieldGet(this, _ApiClient_auth, "f").getCurrentUser();
            }
            catch (err) {
                logger.error(err);
            }
            if (!user) {
                throw new Error('Must be signed in to sign the request.');
            }
        }
        // Sign the request.
        if ((_c = params.options) === null || _c === void 0 ? void 0 : _c.signRequest) {
            await __classPrivateFieldGet(this, _ApiClient_instances, "m", _ApiClient_signRequest).call(this, request, user, {
                now: Math.floor(__classPrivateFieldGet(this, _ApiClient_timeDrifter, "f").date.getTime() / 1000)
            });
        }
        let response;
        try {
            response = await fetch(request.scheme + '://' + request.authority + request.path, {
                body: request.body,
                headers: request.headers,
                method: request.method
            });
        }
        catch (err) {
            logger.error(err);
            throw new Error('Something went wrong');
        }
        // Might be a drift
        if (((_d = params.options) === null || _d === void 0 ? void 0 : _d.signRequest) && response.status === HttpStatus.UNAUTHORIZED) {
            const date = response.headers.get(HttpHeader.DATE);
            if (__classPrivateFieldGet(this, _ApiClient_timeDrifter, "f").update(date)) {
                response = await this.request(params);
            }
        }
        if (response.status >= 300) {
            return response;
        }
        if (!((_e = params.options) === null || _e === void 0 ? void 0 : _e.verifyResponse)) {
            return response;
        }
        // Verify response signature.
        if ((_f = params.options) === null || _f === void 0 ? void 0 : _f.verifyResponse) {
            const responseClone = response.clone();
            const isValid = await __classPrivateFieldGet(this, _ApiClient_instances, "m", _ApiClient_verifyResponse).call(this, responseClone, user);
            if (!isValid) {
                throw new Error('Response couldn\'t be verified');
            }
        }
        return response;
    }
}
_ApiClient_auth = new WeakMap(), _ApiClient_endpoint = new WeakMap(), _ApiClient_timeDrifter = new WeakMap(), _ApiClient_instances = new WeakSet(), _ApiClient_signRequest = 
/**
 * @param {Object} request
 * @param {User} user
 * @param {any} [options]
 */
async function _ApiClient_signRequest(request, user, options) {
    options = options || {};
    const alg = user.subSigAlg;
    const keyId = user.subSigKeyId;
    let created = Math.floor(Date.now() / 1000);
    let expires;
    if (typeof options.now !== 'undefined') {
        if (typeof options.now !== 'number') {
            throw new Error('\'now\' should be a number of seconds');
        }
        else {
            created = options.now;
        }
    }
    if (typeof options.expiresIn !== 'undefined') {
        if (typeof options.expiresIn !== 'number') {
            throw new Error('\'expiresIn\' should be a number of seconds');
        }
        else {
            expires = created + options.expiresIn;
        }
    }
    // Map request data to http headers for http2 protocol.
    const headers = Object.assign(Object.assign({}, request.headers), { [HttpHeader.AUTHORITY]: request.authority, [HttpHeader.METHOD]: request.method, [HttpHeader.PATH]: request.path });
    // We have no control over other headers added by browsers, proxies or other network interceptors.
    const signedHeaders = Object.keys(headers).sort();
    const sortedHeaders = signedHeaders.reduce((acc, key) => {
        acc[key] = headers[key];
        return acc;
    }, {});
    let body;
    if (typeof request.body === 'undefined') {
        body = new Uint8Array(0);
    }
    else if (typeof request.body === 'string') {
        body = new TextEncoder().encode(request.body);
    }
    else if (request.body instanceof Uint8Array) {
        body = request.body;
    }
    else if (request.body instanceof ArrayBuffer) {
        body = new Uint8Array(request.body);
    }
    else if (request.body.buffer instanceof ArrayBuffer) {
        body = new Uint8Array(request.body.buffer);
    }
    else {
        throw new Error('\'body\' must be string, ArrayBuffer or TypedArray');
    }
    const dataToSign = concatUint8Arrays(CBOR.encode({
        alg,
        keyId,
        created,
        expires,
        signedHeaders
    }), CBOR.encode(sortedHeaders), body);
    const sig = user.signMessage(dataToSign);
    const signature = {
        alg,
        keyId,
        created,
        expires,
        signedHeaders,
        sig
    };
    request.headers[HttpHeader.X_ZALTER_SIGNATURE] = Base64Url.fromBase64(Buffer.from(CBOR.encode(signature)).toString('base64'));
}, _ApiClient_verifyResponse = 
/**
 * @param {Response} response
 * @param {User} user
 * @param {any} [options]
 * @return {boolean}
 */
async function _ApiClient_verifyResponse(response, user, options) {
    options = options || {};
    const signatureHeader = response.headers.get(HttpHeader.X_ZALTER_SIGNATURE);
    if (!signatureHeader) {
        logger.error('Missing signature header');
        return false;
    }
    let signature;
    try {
        signature = CBOR.decode(Buffer.from(Base64Url.toBase64(signatureHeader), 'base64'));
    }
    catch (_a) {
        logger.error('Invalid signature header');
        return false;
    }
    let now = Math.floor(Date.now() / 1000);
    if (typeof options.now !== 'undefined') {
        if (typeof options.now !== 'number') {
            throw new Error('\'now\' should be a number');
        }
        else {
            now = options.now;
        }
    }
    // TODO: Verify signature.created and signature.expires are not before now when defined
    if (typeof signature.expires !== 'undefined') {
        if (typeof signature.expires !== 'number') {
            logger.error('Invalid \'expires\' value');
            return false;
        }
    }
    if (typeof options.maxAge !== 'undefined') {
        if (typeof options.maxAge !== 'number') {
            throw new Error('\'maxAge\' should be a number of seconds');
        }
        if (typeof signature.created !== 'number') {
            logger.error('\'maxAge\' specified but \'created\' value missing or invalid');
            return false;
        }
        if (now >= signature.created + options.maxAge) {
            logger.error('\'maxAge\' exceeded');
            return false;
        }
    }
    if (signature.alg !== 'Ed25519') {
        logger.error('Invalid \'alg\' value');
        return false;
    }
    if (signature.keyId && typeof signature.keyId !== 'string') {
        logger.error('Invalid \'keyId\' value');
        return false;
    }
    if (!(signature.sig instanceof Uint8Array)) {
        logger.error('Invalid \'sig\' value');
        return false;
    }
    if (!(Array.isArray(signature.signedHeaders)) ||
        !signature.signedHeaders.every((item) => (typeof item === 'string'))) {
        logger.error('Invalid \'signature.signedHeaders\' value');
        return false;
    }
    // @ts-ignore
    const headers = Object.fromEntries(response.headers.entries());
    // Map response data to http headers for http2 protocol
    headers[HttpHeader.STATUS] = response.status;
    const signedHeadersData = (signature.signedHeaders || []).reduce((acc, key) => {
        acc[key] = headers[key];
        return acc;
    }, {});
    const body = new Uint8Array(await response.arrayBuffer());
    const dataToVerify = concatUint8Arrays(CBOR.encode({
        alg: signature.alg,
        keyId: signature.keyId,
        created: signature.created,
        expires: signature.expires,
        signedHeaders: signature.signedHeaders
    }), CBOR.encode(signedHeadersData), body);
    // TODO: Verify keyId is known by the user
    try {
        return user.verifyMessage(dataToVerify, signature.sig);
    }
    catch (err) {
        logger.error('Invalid signature', err);
        return false;
    }
};

export { ApiClient, Auth, TimeDrifter };
