"use strict";
// Copyright (C) 2017 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
var float_1 = require("./float");
describe("isNegativeZero", function () {
    it("should return true for -0", function () {
        expect(float_1.isNegativeZero(-0)).toBe(true);
    });
    it("should return false for +0", function () {
        expect(float_1.isNegativeZero(0)).toBe(false);
    });
    it("should return false for 1", function () {
        expect(float_1.isNegativeZero(1)).toBe(false);
    });
    it("should return false for -1", function () {
        expect(float_1.isNegativeZero(-1)).toBe(false);
    });
    it("should return false for -Infinity", function () {
        expect(float_1.isNegativeZero(-Infinity)).toBe(false);
    });
    it("should return false for +Infinity", function () {
        expect(float_1.isNegativeZero(+Infinity)).toBe(false);
    });
    it("should return false for NaN", function () {
        expect(float_1.isNegativeZero(NaN)).toBe(false);
    });
});
describe("fround", function () {
    it("should return correct values for test vectors", function () {
        var vectors = [
            [0, 0],
            [1, 1],
            [1.337, 1.3370000123977661],
            [1.5, 1.5],
            [-1, -1],
            [-1.337, -1.3370000123977661],
            [Infinity, Infinity],
            [-Infinity, -Infinity],
            [-1.337, -1.3370000123977661]
        ];
        vectors.forEach(function (_a) {
            var arg = _a[0], result = _a[1];
            expect(float_1.fround(arg)).toBe(result);
        });
        expect(isNaN(float_1.fround(NaN))).toBe(true);
        expect(float_1.isNegativeZero(float_1.fround(-0))).toBe(true);
    });
});
//# sourceMappingURL=float.test.js.map