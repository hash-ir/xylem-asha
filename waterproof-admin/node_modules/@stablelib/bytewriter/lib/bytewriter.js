"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package bytewriter implements byte array writer.
 */
var wipe_1 = require("@stablelib/wipe");
var int_1 = require("@stablelib/int");
var binary_1 = require("@stablelib/binary");
/** Preallocated empty array */
var MIN_CAPACITY = 8;
/**
 * ByteWriter is a convenient way to combine bytes into Uint8Array.
 */
var ByteWriter = /** @class */ (function () {
    /**
     * Creates a new ByteWriter with the optional initial capacity.
     */
    function ByteWriter(initialCapacity) {
        if (initialCapacity === void 0) { initialCapacity = MIN_CAPACITY; }
        this._prev = []; // previous byte arrays
        this._pos = 0; // position in _arr
        this._len = 0; // total length
        this._finished = false;
        this.writeUint8 = this.writeByte;
        this.writeInt64BE = this.writeUint64BE;
        this.writeInt64LE = this.writeUint64LE;
        this._arr = new Uint8Array(initialCapacity);
        this._view = new DataView(this._arr.buffer);
    }
    Object.defineProperty(ByteWriter.prototype, "length", {
        /**
         * Returns the current total length of byte array.
         */
        get: function () {
            return this._len;
        },
        enumerable: true,
        configurable: true
    });
    // Returns the position to write to.
    ByteWriter.prototype._resize = function (add) {
        var newLen = this._len + add;
        if (!int_1.isSafeInteger(newLen)) {
            throw new Error("ByteWriter: result is too large");
        }
        var newPos = this._pos + add;
        if (newPos < this._arr.length) {
            // No resizing needed, record new length and position.
            this._len = newLen;
            var oldPos = this._pos;
            this._pos = newPos;
            return oldPos;
        }
        // Not enough space for new addition.
        // Remember this byte array and create a new one.
        this._prev.push(this._arr.subarray(0, this._pos));
        // Allocate new byte array double the size of the previous one.
        var newCap = Math.max(this._arr.length * 2, MIN_CAPACITY);
        // If it's not enough, just allocate as asked.
        if (newCap < add) {
            newCap = add;
        }
        this._arr = new Uint8Array(newCap);
        this._view = new DataView(this._arr.buffer);
        this._pos = add;
        this._len = newLen;
        return 0;
    };
    // Makes sure buffer can accept len bytes by expanding it if needed.
    // Returns position to write to.
    ByteWriter.prototype._ensureSpace = function (add) {
        if (this._finished) {
            throw new Error("ByteWriter: writing to finished writer");
        }
        return this._resize(add);
    };
    /**
     * Resets position.
     */
    ByteWriter.prototype.reset = function () {
        // _arr and _view stay the same, everything else is reset.
        wipe_1.wipe(this._arr);
        this._prev = [];
        this._len = 0;
        this._pos = 0;
        this._finished = false;
        return this;
    };
    /**
     * Returns the resulting byte array.
     */
    ByteWriter.prototype.finish = function () {
        if (this._finished) {
            throw new Error("ByteWriter is already finished");
        }
        this._finished = true;
        // Push the current array.
        this._prev.push(this._arr.subarray(0, this._pos));
        // Concatenate all arrays.
        var result = new Uint8Array(this._len);
        var offset = 0;
        for (var i = 0; i < this._prev.length; i++) {
            var arr = this._prev[i];
            result.set(arr, offset);
            offset += arr.length;
        }
        return result;
    };
    ByteWriter.prototype.clean = function () {
        this._prev.forEach(function (arr) { return wipe_1.wipe(arr); });
        this.reset();
    };
    ByteWriter.prototype.write = function (arr) {
        var pos = this._ensureSpace(arr.length);
        this._arr.set(arr, pos);
        return this;
    };
    ByteWriter.prototype.writeMany = function (arrays) {
        var _this = this;
        arrays.forEach(function (item) { return _this.write(item); });
        return this;
    };
    ByteWriter.prototype.writeByte = function (byte) {
        var pos = this._ensureSpace(1);
        this._arr[pos] = byte;
        return this;
    };
    ByteWriter.prototype.writeUint16BE = function (value) {
        var pos = this._ensureSpace(2);
        this._view.setUint16(pos, value, false);
        return this;
    };
    ByteWriter.prototype.writeInt16BE = function (value) {
        var pos = this._ensureSpace(2);
        this._view.setInt16(pos, value, false);
        return this;
    };
    ByteWriter.prototype.writeUint16LE = function (value) {
        var pos = this._ensureSpace(2);
        this._view.setUint16(pos, value, true);
        return this;
    };
    ByteWriter.prototype.writeInt16LE = function (value) {
        var pos = this._ensureSpace(2);
        this._view.setInt16(pos, value, true);
        return this;
    };
    ByteWriter.prototype.writeUint32BE = function (value) {
        var pos = this._ensureSpace(4);
        this._view.setUint32(pos, value, false);
        return this;
    };
    ByteWriter.prototype.writeInt32BE = function (value) {
        var pos = this._ensureSpace(4);
        this._view.setInt32(pos, value, false);
        return this;
    };
    ByteWriter.prototype.writeUint32LE = function (value) {
        var pos = this._ensureSpace(4);
        this._view.setUint32(pos, value, true);
        return this;
    };
    ByteWriter.prototype.writeInt32LE = function (value) {
        var pos = this._ensureSpace(4);
        this._view.setInt32(pos, value, true);
        return this;
    };
    ByteWriter.prototype.writeUint64BE = function (value) {
        var pos = this._ensureSpace(8);
        binary_1.writeUint64BE(value, this._arr, pos);
        return this;
    };
    ByteWriter.prototype.writeUint64LE = function (value) {
        var pos = this._ensureSpace(8);
        binary_1.writeUint64LE(value, this._arr, pos);
        return this;
    };
    ByteWriter.prototype.writeUintLE = function (bitLength, value) {
        var pos = this._ensureSpace(bitLength / 8);
        binary_1.writeUintLE(bitLength, value, this._arr, pos);
        return this;
    };
    ByteWriter.prototype.writeUintBE = function (bitLength, value) {
        var pos = this._ensureSpace(bitLength / 8);
        binary_1.writeUintBE(bitLength, value, this._arr, pos);
        return this;
    };
    ByteWriter.prototype.writeFloat32BE = function (value) {
        var pos = this._ensureSpace(4);
        this._view.setFloat32(pos, value, false);
        return this;
    };
    ByteWriter.prototype.writeFloat32LE = function (value) {
        var pos = this._ensureSpace(4);
        this._view.setFloat32(pos, value, true);
        return this;
    };
    ByteWriter.prototype.writeFloat64BE = function (value) {
        var pos = this._ensureSpace(8);
        this._view.setFloat64(pos, value, false);
        return this;
    };
    ByteWriter.prototype.writeFloat64LE = function (value) {
        var pos = this._ensureSpace(8);
        this._view.setFloat64(pos, value, true);
        return this;
    };
    return ByteWriter;
}());
exports.ByteWriter = ByteWriter;
//# sourceMappingURL=bytewriter.js.map