"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Package cbor implements CBOR (Concise Binary Object Representation) encoder and decoder.
 */
var utf8 = require("@stablelib/utf8");
var bytewriter_1 = require("@stablelib/bytewriter");
var bytereader_1 = require("@stablelib/bytereader");
var int_1 = require("@stablelib/int");
var float_1 = require("@stablelib/float");
/**
 * CBOR (Concise Binary Object Representation)
 * https://tools.ietf.org/html/rfc7049
 */
var MAX_UINT8 = 255;
var MAX_UINT16 = Math.pow(2, 16) - 1;
var MAX_UINT32 = Math.pow(2, 32) - 1;
// Major types.
var MT_UNSIGNED_INT = 0;
var MT_NEGATIVE_INT = 1;
var MT_BYTE_STRING = 2;
var MT_TEXT_STRING = 3;
var MT_ARRAY = 4;
var MT_MAP = 5;
var MT_TAG = 6;
var MT_SIMPLE_OR_FLOAT = 7;
// Additional information.
var AI_FALSE = 20;
var AI_TRUE = 21;
var AI_NULL = 22;
var AI_UNDEFINED = 23;
var AI_8_BITS = 24;
var AI_16_BITS = 25;
var AI_32_BITS = 26;
var AI_64_BITS = 27;
var AI_STOP = 31;
var STOP_BYTE = 0xff;
/**
 * Common tags.
 */
var Tags;
(function (Tags) {
    Tags[Tags["DateString"] = 0] = "DateString";
    Tags[Tags["DateNumber"] = 1] = "DateNumber";
    Tags[Tags["PositiveBigNum"] = 2] = "PositiveBigNum";
    Tags[Tags["NegativeBigNum"] = 3] = "NegativeBigNum";
    Tags[Tags["Decimal"] = 4] = "Decimal";
    Tags[Tags["BigFloat"] = 5] = "BigFloat";
    Tags[Tags["URI"] = 32] = "URI";
    Tags[Tags["Base64URL"] = 33] = "Base64URL";
    Tags[Tags["Base64"] = 34] = "Base64";
    Tags[Tags["RegExp"] = 35] = "RegExp";
    Tags[Tags["MIMEMessage"] = 36] = "MIMEMessage";
    Tags[Tags["CBOR"] = 24] = "CBOR";
    Tags[Tags["CBORSelf"] = 55799] = "CBORSelf";
})(Tags = exports.Tags || (exports.Tags = {}));
/**
 * Tagged value.
 *
 * Predefined tags are listed in Tags enum.
 *
 * Some tagged values are handled automatically by default (Tags.DateString and
 * Tags.DateNumber correspond to Date object, Tags.RegExp to RegExp). Others
 * are returned as an instance of Tagged, unless encoder/decoder is provided
 * with customer converters. If Tagged is passed to encoder, it will properly
 * encode it.
 *
 * IANA keeps "CBOR Tags" registry (see RFC 7049, Section 7.2).
 */
var Tagged = /** @class */ (function () {
    function Tagged(tag, value) {
        this.tag = tag;
        this.value = value;
    }
    return Tagged;
}());
exports.Tagged = Tagged;
exports.DateStringEncoder = function (date) {
    if (!(date instanceof Date)) {
        return undefined;
    }
    return new Tagged(Tags.DateString, date.toISOString().slice(0, 19) + "Z");
};
exports.DateStringDecoder = function (_a) {
    var tag = _a.tag, value = _a.value;
    if (tag !== Tags.DateString) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new Error("cbor: unexpected type for date string: \"" + typeof value + "\"");
    }
    if (!ISO_DATE_RX.test(value)) {
        throw new Error("cbor: invalid date string format");
    }
    return new Date(value);
};
// This encoder is unused by default, because dates are processed with
// DateStringEncoder. The decoder is used, though.
exports.DateNumberEncoder = function (date) {
    if (!(date instanceof Date)) {
        return undefined;
    }
    return new Tagged(Tags.DateNumber, date.getTime() / 1000);
};
exports.DateNumberDecoder = function (_a) {
    var tag = _a.tag, value = _a.value;
    if (tag !== Tags.DateNumber) {
        return undefined;
    }
    if (typeof value !== "number") {
        throw new Error("cbor: unexpected type for date number: \"" + typeof value + "\"");
    }
    return new Date(value * 1000);
};
exports.RegExpEncoder = function (rx) {
    if (!(rx instanceof RegExp)) {
        return undefined;
    }
    return new Tagged(Tags.RegExp, rx.toString());
};
exports.RegExpDecoder = function (_a) {
    var tag = _a.tag, value = _a.value;
    if (tag !== Tags.RegExp) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new Error("cbor: unexpected type for regexp: \"" + typeof value + "\"");
    }
    var matches = value.match(/^\/(.*)\/(.*)$/);
    if (!matches || matches.length < 3) {
        throw new Error('cbor: invalid regexp format');
    }
    return new RegExp(matches[1], matches[2]);
};
/**
 * Default tagged values encoders.
 */
exports.DEFAULT_TAGGED_ENCODERS = [
    exports.DateStringEncoder,
    exports.RegExpEncoder
];
/**
 * Default tagged values decoders.
 */
exports.DEFAULT_TAGGED_DECODERS = [
    exports.DateStringDecoder,
    exports.DateNumberDecoder,
    exports.RegExpDecoder
];
/**
 * Simple values are some predefined (see RFC 7049, Section 2.3),
 * others are assigned by IANA "CBOR Simple Values" registry
 * (Section 7.1).
 */
var Simple = /** @class */ (function () {
    function Simple(value) {
        this.value = value;
    }
    return Simple;
}());
exports.Simple = Simple;
// tslint:disable-next-line: max-line-length
var ISO_DATE_RX = /^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(([Zz])|([\+|\-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
exports.DEFAULT_ENCODER_OPTIONS = {
    intKeys: false,
    taggedEncoders: exports.DEFAULT_TAGGED_ENCODERS
};
/**
 * Encoder encodes values into CBOR format.
 */
var Encoder = /** @class */ (function () {
    function Encoder(options, writer) {
        if (options === void 0) { options = exports.DEFAULT_ENCODER_OPTIONS; }
        if (writer === void 0) { writer = new bytewriter_1.ByteWriter(); }
        this._buf = writer;
        this._opt = options;
        this._taggedEncoders = options.taggedEncoders || exports.DEFAULT_TAGGED_ENCODERS;
    }
    Encoder.prototype.finish = function () {
        return this._buf.finish();
    };
    Encoder.prototype.reset = function () {
        this._buf.clean();
        this._buf.reset();
        return this;
    };
    Encoder.prototype.clean = function () {
        this._buf.clean();
    };
    Encoder.prototype.encode = function (value) {
        switch (typeof value) {
            case "undefined":
                return this.encodeUndefined();
            case "boolean":
                return this.encodeBoolean(value);
            case "number":
                return this.encodeNumber(value);
            case "string":
                return this.encodeString(value);
            case "object":
                return this.encodeObject(value);
            default:
                throw new Error("cbor: cannot encode type \"" + typeof value + "\"");
        }
    };
    Encoder.prototype.encodeTagged = function (tag, value) {
        this._writeMajorTypeAndLength(MT_TAG, tag);
        return this.encode(value);
    };
    Encoder.prototype.encodeSimple = function (value) {
        if (value < 0 || value > 255) {
            throw new Error("cbor: incorrect simple value " + value);
        }
        this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, value);
        return this;
    };
    Encoder.prototype._writeMajorTypeAndLength = function (type, length) {
        if (length < AI_8_BITS) {
            this._buf.writeByte(type << 5 | length);
        }
        else if (length <= MAX_UINT8) {
            this._buf.writeByte(type << 5 | AI_8_BITS);
            this._buf.writeByte(length);
        }
        else if (length <= MAX_UINT16) {
            this._buf.writeByte(type << 5 | AI_16_BITS);
            this._buf.writeUint16BE(length);
        }
        else if (length <= MAX_UINT32) {
            this._buf.writeByte(type << 5 | AI_32_BITS);
            this._buf.writeUint32BE(length);
        }
        else {
            this._buf.writeByte(type << 5 | AI_64_BITS);
            this._buf.writeUint64BE(length);
        }
    };
    Encoder.prototype.encodeBoolean = function (value) {
        if (value) {
            this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, AI_TRUE);
        }
        else {
            this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, AI_FALSE);
        }
        return this;
    };
    Encoder.prototype.encodeNull = function () {
        this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, AI_NULL);
        return this;
    };
    Encoder.prototype.encodeUndefined = function () {
        this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, AI_UNDEFINED);
        return this;
    };
    Encoder.prototype.encodeNumber = function (value) {
        if (value === 0) {
            // Distinguish between -0 and +0
            if (float_1.isNegativeZero(value)) {
                // -0. We could use this._encodeDouble(value), to encode
                // float32, but instead we'll write float16 manually.
                this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, 0x8000);
            }
            else {
                this.encodeInteger(value); // +0
            }
        }
        else if (int_1.isSafeInteger(value)) {
            this.encodeInteger(value);
        }
        else {
            this.encodeDouble(value);
        }
        return this;
    };
    Encoder.prototype.encodeInteger = function (value) {
        if (value < 0) {
            this._writeMajorTypeAndLength(MT_NEGATIVE_INT, -(value + 1));
        }
        else {
            this._writeMajorTypeAndLength(MT_UNSIGNED_INT, value);
        }
        return this;
    };
    Encoder.prototype.encodeDouble = function (value) {
        // Encode some common values as float16.
        if (value === Infinity) {
            this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, 0x7c00);
            return this;
        }
        else if (value === -Infinity) {
            this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, 0xfc00);
            return this;
        }
        else if (isNaN(value)) {
            this._writeMajorTypeAndLength(MT_SIMPLE_OR_FLOAT, 0x7e00);
            return this;
        }
        // Find minimal encoding: float32 or float64.
        if (value === float_1.fround(value)) {
            // Can be encoded in 32 bits.
            this._buf.writeByte(MT_SIMPLE_OR_FLOAT << 5 | AI_32_BITS);
            this._buf.writeFloat32BE(value);
        }
        else {
            // Use full 64-bit encoding.
            this._buf.writeByte(MT_SIMPLE_OR_FLOAT << 5 | AI_64_BITS);
            this._buf.writeFloat64BE(value);
        }
        return this;
    };
    Encoder.prototype.encodeString = function (value) {
        // TODO(dchest): use byte-by-byte utf8 encoding
        // to (probably) improve performance.
        var b = utf8.encode(value);
        this._writeMajorTypeAndLength(MT_TEXT_STRING, b.length);
        this._buf.write(b);
        return this;
    };
    Encoder.prototype.encodeBytes = function (value) {
        this._writeMajorTypeAndLength(MT_BYTE_STRING, value.length);
        this._buf.write(value);
        return this;
    };
    Encoder.prototype.encodeArray = function (value) {
        var _this = this;
        this._writeMajorTypeAndLength(MT_ARRAY, value.length);
        value.forEach(function (item) { return _this.encode(item); });
        return this;
    };
    Encoder.prototype.encodeObject = function (value) {
        if (value === null) {
            return this.encodeNull();
        }
        else if (Array.isArray(value)) {
            return this.encodeArray(value);
        }
        else if (value instanceof Uint8Array) {
            return this.encodeBytes(value);
        }
        else if (value instanceof ArrayBuffer) {
            return this.encodeBytes(new Uint8Array(value));
        }
        else if (value instanceof Date) {
            return this.encodeDate(value);
        }
        else if (value instanceof RegExp) {
            return this.encodeRegExp(value);
        }
        else if (value instanceof Simple) {
            return this.encodeSimple(value.value);
        }
        else if (value instanceof Tagged) {
            return this.encodeTagged(value.tag, value.value);
        }
        // Try encoding tagged objects.
        for (var i = 0; i < this._taggedEncoders.length; i++) {
            var result = this._taggedEncoders[i](value);
            if (result) { // skip any falsy result
                return this.encodeTagged(result.tag, result.value);
            }
        }
        return this.encodeMap(value);
    };
    Encoder.prototype.encodeMap = function (value) {
        var _this = this;
        var keys = Object.keys(value);
        this._writeMajorTypeAndLength(MT_MAP, keys.length);
        keys.forEach(function (key) {
            // If intKeys option is true, try converting key to integer and
            // encode it as such. Otherwise, or if conversion fails, encode it
            // as string.
            if (_this._opt.intKeys) {
                var v = parseInt(key, 10);
                // Make sure the whole key was parsed as integer.
                // NOTE: numbers with plus sign (+1) will be considered
                // strings, numbers with minus sign (-1) will be considered
                // integers.
                if (!isNaN(v) && String(v) === key) {
                    _this.encodeInteger(v);
                }
                else {
                    _this.encodeString(key);
                }
            }
            else {
                _this.encodeString(key);
            }
            _this.encode(value[key]);
        });
        return this;
    };
    Encoder.prototype.encodeDate = function (value) {
        return this.encodeTagged(Tags.DateString, value.toISOString().slice(0, 19) + "Z");
    };
    Encoder.prototype.encodeRegExp = function (value) {
        return this.encodeTagged(Tags.RegExp, value.toString());
    };
    return Encoder;
}());
exports.Encoder = Encoder;
/**
 * Encodes the given value as CBOR.
 */
function encode(value, options) {
    var enc = new Encoder(options);
    var result = enc.encode(value).finish();
    enc.clean();
    return result;
}
exports.encode = encode;
exports.DEFAULT_DECODER_OPTIONS = {
    noCopy: false,
    ignoreExtraData: false,
    taggedDecoders: exports.DEFAULT_TAGGED_DECODERS
};
/**
 * Decoder decodes values from CBOR format.
 */
var Decoder = /** @class */ (function () {
    /**
     * Creates decoder.
     * If noCopy is true, all read Uint8Arrays will be the subarrays of src.
     *
     * If ignoreExtraData is true, decoder will not throw if there's undecoded
     * data at the end of the source.
     */
    function Decoder(src, options) {
        if (options === void 0) { options = exports.DEFAULT_DECODER_OPTIONS; }
        this._r = new bytereader_1.ByteReader(src);
        this._opt = options;
        this._taggedDecoders = options.taggedDecoders || exports.DEFAULT_TAGGED_DECODERS;
    }
    Decoder.prototype.decode = function () {
        var result = this._decodeValue();
        if (!this._opt.ignoreExtraData && this.undecodedLength !== 0) {
            throw new Error("cbor: extra data at the end");
        }
        return result;
    };
    Object.defineProperty(Decoder.prototype, "undecodedLength", {
        /**
         * Gets the number of undecoded bytes left in the buffer.
         */
        get: function () {
            return this._r.unreadLength;
        },
        enumerable: true,
        configurable: true
    });
    Decoder.prototype._readLength = function (additionalInfo) {
        if (additionalInfo < AI_8_BITS) {
            return additionalInfo;
        }
        else if (additionalInfo === AI_8_BITS) {
            return this._r.readByte();
        }
        else if (additionalInfo === AI_16_BITS) {
            return this._r.readUint16BE();
        }
        else if (additionalInfo === AI_32_BITS) {
            return this._r.readUint32BE();
        }
        else if (additionalInfo === AI_64_BITS) {
            var value = this._r.readUint64BE();
            if (!int_1.isSafeInteger(value)) {
                throw new Error("cbor: 64-bit value is too large");
            }
            return value;
        }
        else if (additionalInfo === AI_STOP) {
            return Infinity; // indefinite-length item
        }
        else {
            throw new Error("cbor: unsupported (reserved) length");
        }
    };
    Decoder.prototype._decodeValue = function (firstByte) {
        if (firstByte === void 0) { firstByte = this._r.readByte(); }
        var majorType = firstByte >> 5;
        var additionalInfo = firstByte & 31;
        // Read float/simple early to avoid reading length.
        if (majorType === MT_SIMPLE_OR_FLOAT) {
            return this._decodeSimpleOrFloat(additionalInfo);
        }
        var length = this._readLength(additionalInfo);
        switch (majorType) {
            case MT_UNSIGNED_INT:
                return this._decodeUnsignedInteger(length);
            case MT_NEGATIVE_INT:
                return this._decodeNegativeInteger(length);
            case MT_BYTE_STRING:
                return this._decodeBytes(length);
            case MT_TEXT_STRING:
                return this._decodeString(length);
            case MT_ARRAY:
                return this._decodeArray(length);
            case MT_MAP:
                return this._decodeMap(length);
            case MT_TAG:
                return this._decodeTagged(length);
            default:
                // Note: MT_SIMPLE_OR_FLOAT is decoded earlier.
                throw new Error("cbor: unexpected major type " + majorType);
        }
    };
    Decoder.prototype._decodeSimple = function (value) {
        switch (value) {
            case AI_FALSE:
                return false;
            case AI_TRUE:
                return true;
            case AI_NULL:
                return null;
            case AI_UNDEFINED:
                return undefined;
            case AI_STOP:
                // Note: AI_STOP is handled by indefinite readers.
                throw new Error("cbor: programmer error! Stop not handled.");
            default:
                return new Simple(value);
        }
    };
    Decoder.prototype._decodeSimpleOrFloat = function (additionalInfo) {
        if (additionalInfo < AI_8_BITS) {
            return this._decodeSimple(additionalInfo);
        }
        else if (additionalInfo === AI_8_BITS) {
            return this._decodeSimple(this._r.readByte());
        }
        else if (additionalInfo === AI_16_BITS) {
            return this._decodeFloat16();
        }
        else if (additionalInfo === AI_32_BITS) {
            return this._r.readFloat32BE();
        }
        else if (additionalInfo === AI_64_BITS) {
            return this._r.readFloat64BE();
        }
        else {
            // Note: AI_STOP is handled by indefinite readers.
            throw new Error("cbor: unsupported float length");
        }
    };
    Decoder.prototype._decodeFloat16 = function () {
        var u = this._r.readUint16BE();
        var exponent = (u & 0x7C00) >> 10;
        var fraction = u & 0x03FF;
        var value;
        if (exponent === 0) {
            value = 6.103515625e-5 * (fraction / 0x400);
        }
        else if (exponent === 0x1f) {
            value = fraction ? NaN : Infinity;
        }
        else {
            value = Math.pow(2, exponent - 15) * (1 + fraction / 0x400);
        }
        if (u & 0x8000) {
            return -value;
        }
        else {
            return value;
        }
    };
    Decoder.prototype._decodeUnsignedInteger = function (length) {
        return length;
    };
    Decoder.prototype._decodeNegativeInteger = function (length) {
        return -1 - length;
    };
    Decoder.prototype._decodeString = function (length) {
        // TODO(dchest): make utf8 decoding inline.
        if (length === Infinity) {
            return this._decodeIndefiniteString();
        }
        return utf8.decode(this._r.readNoCopy(length));
    };
    Decoder.prototype._decodeIndefiniteString = function () {
        var result = "";
        var b;
        while ((b = this._r.readByte()) !== STOP_BYTE) {
            var majorType = b >> 5;
            var length_1 = this._readLength(b & 31);
            if (majorType !== MT_TEXT_STRING || length_1 === Infinity) {
                throw new Error("cbor: incorrect indefinite string encoding");
            }
            result += utf8.decode(this._r.readNoCopy(length_1));
        }
        return result;
    };
    Decoder.prototype._decodeBytes = function (length) {
        if (length === Infinity) {
            return this._decodeIndefiniteBytes();
        }
        if (this._opt.noCopy) {
            return this._r.readNoCopy(length);
        }
        return this._r.read(length);
    };
    Decoder.prototype._decodeIndefiniteBytes = function () {
        var buf = new bytewriter_1.ByteWriter();
        var b;
        while ((b = this._r.readByte()) !== STOP_BYTE) {
            var majorType = b >> 5;
            var length_2 = this._readLength(b & 31);
            if (majorType !== MT_BYTE_STRING || length_2 === Infinity) {
                throw new Error("cbor: incorrect indefinite bytes encoding (type=" + majorType + ")");
            }
            buf.write(this._r.readNoCopy(length_2));
        }
        var result = buf.finish();
        buf.clean();
        return result;
    };
    Decoder.prototype._decodeArray = function (length) {
        if (length === Infinity) {
            return this._decodeIndefiniteArray();
        }
        var result = [];
        for (var i = 0; i < length; i++) {
            result.push(this._decodeValue());
        }
        return result;
    };
    Decoder.prototype._decodeIndefiniteArray = function () {
        var result = [];
        var b;
        while ((b = this._r.readByte()) !== STOP_BYTE) {
            result.push(this._decodeValue(b));
        }
        return result;
    };
    Decoder.prototype._decodeMap = function (length) {
        if (length === Infinity) {
            return this._decodeIndefiniteMap();
        }
        var result = {};
        for (var i = 0; i < length; i++) {
            var key = this._decodeValue();
            if (this._opt.strictMapKeys &&
                (typeof key !== "number" && typeof key !== "string")) {
                throw new Error("cbor: wrong map key type \"" + typeof key + "\"");
            }
            if (this._opt.uniqueMapKeys && (key in result)) {
                throw new Error("cbor: duplicate map key: \"" + key + "\"");
            }
            var value = this._decodeValue();
            result[key] = value;
        }
        return result;
    };
    Decoder.prototype._decodeIndefiniteMap = function () {
        var result = {};
        var b;
        while ((b = this._r.readByte()) !== STOP_BYTE) {
            var key = this._decodeValue(b);
            if (this._opt.strictMapKeys &&
                (typeof key !== "number" && typeof key !== "string")) {
                throw new Error("cbor: wrong map key type \"" + typeof key + "\"");
            }
            if (this._opt.uniqueMapKeys && (key in result)) {
                throw new Error("cbor: duplicate map key: \"" + key + "\"");
            }
            var value = this._decodeValue();
            result[key] = value;
        }
        return result;
    };
    Decoder.prototype._decodeTagged = function (tag) {
        var tagged = new Tagged(tag, this._decodeValue());
        for (var i = 0; i < this._taggedDecoders.length; i++) {
            var result = this._taggedDecoders[i](tagged);
            if (result !== undefined) {
                return result;
            }
        }
        return tagged;
    };
    return Decoder;
}());
exports.Decoder = Decoder;
/**
 * Decodes src from CBOR.
 *
 * If noCopy is true, the returned Uint8Arrays will be a subarrays of src
 * otherwise they will be newly allocated. It is not recommended to set it to
 * true, due to the possibility of hard-to-detect bugs resulting from it and
 * preventing chunks of memory from being garbage collected.
 *
 * If ignoreExtraData is true, decoder will not throw an error if there's
 * undecoded data at the end of the source.
 */
function decode(src, options) {
    return new Decoder(src, options).decode();
}
exports.decode = decode;
//# sourceMappingURL=cbor.js.map