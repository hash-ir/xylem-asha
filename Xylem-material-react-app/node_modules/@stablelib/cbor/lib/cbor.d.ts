import { ByteWriter } from "@stablelib/bytewriter";
/**
 * Common tags.
 */
export declare enum Tags {
    DateString = 0,
    DateNumber = 1,
    PositiveBigNum = 2,
    NegativeBigNum = 3,
    Decimal = 4,
    BigFloat = 5,
    URI = 32,
    Base64URL = 33,
    Base64 = 34,
    RegExp = 35,
    MIMEMessage = 36,
    CBOR = 24,
    CBORSelf = 55799
}
/**
 * Tagged value.
 *
 * Predefined tags are listed in Tags enum.
 *
 * Some tagged values are handled automatically by default (Tags.DateString and
 * Tags.DateNumber correspond to Date object, Tags.RegExp to RegExp). Others
 * are returned as an instance of Tagged, unless encoder/decoder is provided
 * with customer converters. If Tagged is passed to encoder, it will properly
 * encode it.
 *
 * IANA keeps "CBOR Tags" registry (see RFC 7049, Section 7.2).
 */
export declare class Tagged {
    tag: number;
    value: any | null | undefined;
    constructor(tag: number, value: any | null | undefined);
}
/**
 * Interface describing a custom tagged value converter.
 */
/**
 * Tagged value encoder.
 *
 * If it can encode the object, it must return a Tagged instance,
 * otherwise must return undefined.
 */
export declare type TaggedEncoder<T> = (obj: T | object) => Tagged | undefined;
/**
 * Tagged value decoder.
 *
 * If it can decode a Tagged value (by checking its tag property),
 * it must return this value, otherwise must return undefined.
 */
export declare type TaggedDecoder<T> = (tagged: Tagged) => T | undefined;
export declare const DateStringEncoder: TaggedEncoder<Date>;
export declare const DateStringDecoder: TaggedDecoder<Date>;
export declare const DateNumberEncoder: TaggedEncoder<Date>;
export declare const DateNumberDecoder: TaggedDecoder<Date>;
export declare const RegExpEncoder: TaggedEncoder<RegExp>;
export declare const RegExpDecoder: TaggedDecoder<RegExp>;
/**
 * Default tagged values encoders.
 */
export declare const DEFAULT_TAGGED_ENCODERS: TaggedEncoder<any>[];
/**
 * Default tagged values decoders.
 */
export declare const DEFAULT_TAGGED_DECODERS: TaggedDecoder<any>[];
/**
 * Simple values are some predefined (see RFC 7049, Section 2.3),
 * others are assigned by IANA "CBOR Simple Values" registry
 * (Section 7.1).
 */
export declare class Simple {
    value: number;
    constructor(value: number);
}
/**
 * Specifies options for encoder.
 */
export declare type EncoderOptions = {
    /**
     * In JavaScript, object keys are strings, so by default CBOR encoding will
     * produce string keys for maps.
     *
     * Setting intKeys to true will make encoder first try to convert each
     * object key to integer and encode it as such if conversion succeeds. Keys
     * that cannot be converted will be encoded as strings. Note that if object
     * contains both integer and string keys, the map will be encoded as such.
     *
     * By default, false.
     */
    intKeys?: boolean;
    /**
     * Tagged object encoders.
     *
     * By default, DEFAULT_TAGGED_ENCODERS, which encodes Dates (as a string)
     * and RegExps.
     *
     * Pass empty array to disable tagged encoders.
     */
    taggedEncoders?: TaggedEncoder<any>[];
};
export declare const DEFAULT_ENCODER_OPTIONS: EncoderOptions;
/**
 * Encoder encodes values into CBOR format.
 */
export declare class Encoder {
    private _buf;
    private _opt;
    private _taggedEncoders;
    constructor(options?: EncoderOptions, writer?: ByteWriter);
    finish(): Uint8Array;
    reset(): this;
    clean(): void;
    encode(value: any | null | undefined): this;
    private encodeTagged;
    encodeSimple(value: number): this;
    private _writeMajorTypeAndLength;
    encodeBoolean(value: boolean): this;
    encodeNull(): this;
    encodeUndefined(): this;
    encodeNumber(value: number): this;
    encodeInteger(value: number): this;
    encodeDouble(value: number): this;
    encodeString(value: string): this;
    encodeBytes(value: Uint8Array): this;
    encodeArray(value: Array<any | null | undefined>): this;
    encodeObject(value: Object): this;
    encodeMap(value: {
        [key: string]: (any | null | undefined);
    }): this;
    encodeDate(value: Date): this;
    encodeRegExp(value: RegExp): this;
}
/**
 * Encodes the given value as CBOR.
 */
export declare function encode(value: any | null | undefined, options?: EncoderOptions): Uint8Array;
/**
 * Specifies options for decoder.
 */
export declare type DecoderOptions = {
    /**
     * If true, instead of copying byte arrays return subarrays into CBOR
     * buffer.
     *
     * By default, false.
     */
    noCopy?: boolean;
    /**
     * If true, ignore extra data at the end of the source buffer.
     * Otherwise, decoder throws an error if extra data is detected.
     *
     * To get the number of extra bytes left, use undecodedLength.
     *
     * By default, false.
     */
    ignoreExtraData?: boolean;
    /**
     * If true, allow only string and number keys for maps.
     * Throw if encountered any other type.
     *
     * By default, false.
     */
    strictMapKeys?: boolean;
    /**
     * If true, map keys must be unique (after conversion to string).
     * Throw if encountered duplicate keys.
     *
     * By default, false.
     */
    uniqueMapKeys?: boolean;
    /**
     * Tagged object decoders.
     *
     * By default, DEFAULT_TAGGED_DECODERS, which converts tagged
     * Tags.DateString and Tags.DateNumber to Date and Tags.RegExp to RegExp
     * objects.
     *
     * Pass empty array to disable tagged decoders.
     */
    taggedDecoders?: TaggedDecoder<any>[];
};
export declare const DEFAULT_DECODER_OPTIONS: DecoderOptions;
/**
 * Decoder decodes values from CBOR format.
 */
export declare class Decoder {
    private _r;
    private _opt;
    private _taggedDecoders;
    /**
     * Creates decoder.
     * If noCopy is true, all read Uint8Arrays will be the subarrays of src.
     *
     * If ignoreExtraData is true, decoder will not throw if there's undecoded
     * data at the end of the source.
     */
    constructor(src: Uint8Array, options?: DecoderOptions);
    decode(): any | null | undefined;
    /**
     * Gets the number of undecoded bytes left in the buffer.
     */
    get undecodedLength(): number;
    private _readLength;
    private _decodeValue;
    private _decodeSimple;
    private _decodeSimpleOrFloat;
    private _decodeFloat16;
    private _decodeUnsignedInteger;
    private _decodeNegativeInteger;
    private _decodeString;
    private _decodeIndefiniteString;
    private _decodeBytes;
    private _decodeIndefiniteBytes;
    private _decodeArray;
    private _decodeIndefiniteArray;
    private _decodeMap;
    private _decodeIndefiniteMap;
    private _decodeTagged;
}
/**
 * Decodes src from CBOR.
 *
 * If noCopy is true, the returned Uint8Arrays will be a subarrays of src
 * otherwise they will be newly allocated. It is not recommended to set it to
 * true, due to the possibility of hard-to-detect bugs resulting from it and
 * preventing chunks of memory from being garbage collected.
 *
 * If ignoreExtraData is true, decoder will not throw an error if there's
 * undecoded data at the end of the source.
 */
export declare function decode(src: Uint8Array, options?: DecoderOptions): any | null | undefined;
